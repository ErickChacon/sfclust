---
title: "Bsfclust-Modeling"
author: "Ruiman Zhong"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{1.Bsfclust-Simulated Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
We begin by loading the required packages. These packages will assist with data manipulation, visualization, and running the `bsfc` algorithm.

```{r warning=FALSE, include=FALSE}
packages <- c("gridExtra", "deldir", "fields", "igraph", 
              "ggplot2", "Matrix.utils", "grid", "class", 
              "spdep", 'sf', 'bsfc','cccd','ggraph','dplyr')

package.check <- lapply(packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE, repos = "http://cran.us.r-project.org")
    library(x, character.only = TRUE)
  } else {
    library(x, character.only = TRUE)
  }
})
```
In this vignette, we utilize the simulation data generated in the previous vignette. To load the data, we use the following command:
```{r}
load("~/Documents/project3/data/simulation_data.rda")
```
In this section, we show how to use Bsfclust algorithm to find the spatial clusters.

```{r}
nt=dim(Y)[1]; ns=dim(Y)[2]  
## build design matrix
time = 1:nt
# compute fixed effects
X = poly(time, 2, raw = TRUE, simple = TRUE)
map <- geodata
```
Now, we would like to start with initializing the model parameters. We will first create 15 initial cluster from a MST. The MST is set from adjacency matrix. The weights of the MST is built from a U[0,1].


```{r echo=TRUE, warning=FALSE}
# Build MST 
k =15
seed = 43
# create graph
geodata = initial.mst.build(map,method='adjmat',nclust = k, weights = NULL, seed = seed)
coords <- st_coordinates(st_centroid(map)[, 3])
plotGraph(map,coords,geodata$graph,"Initial graph")
```
We could also check the initial MST and cluster memberships, by

```{r fig.width=6, fig.height=4}
plotMST(map,coords,geodata$mst,geodata$cluster, "Initial MST")
```
The following example demonstrates how to use the bsfc function to perform spatial functional clustering with a normal likelihood model. The number of the clusters follows 
$$
\pi(C = n_{init})(1-c)^{n_{init}}
$$
```{r}
formula= Yk~ 1+ Xk 
```
```{r eval=FALSE}
result <- bsfc(Y, graphdata = geodata, X = X, N = NULL,
                formula, family = "normal", hyperpar = list(c =  0.5),
                correction = F, niter = 2000, burnin = 0, thin = 1,  path_save = NULL, nsave = 50) 
```
formula defines the model where Yk is the response variable, Xk is a covariate, and f(id, model = "iid") adds a random effect for the id variable using an IID structure.
The bsfc function is applied to the data, with Y representing the observed response data, geodata containing the graph structure, and X representing the covariate matrix.
We specify the family as "normal", set the hyperparameter c to 0.5, and disable bias correction by setting correction = FALSE.
The MCMC sampling process runs for 1000 iterations without burn-in, with thinning set to 1.

## Evaluation of the convergency and continuation of the process
Because the runtime of the whole process, we provide the results here. 
```{r fig.width=6, fig.height=4}
result = readRDS('~/Documents/project3/data/simu_result.rds')
plot(result$log_mlike, type = "l", main = "Marginal Likelihoods of the Initial MCMC Run",
     xlab = "Iteration", ylab = "Marginal Likelihood")
```


Print the final cluster_membership and plot.

```{r fig.width=6, fig.height=4}
clust_res = result$cluster[length(result$mst),]
table(clust_res,geodata$cluster)
plotClusterMap(clust_res, geodata$cluster, map, NULL,title = "(B) Estimated Cluster",fill = "Cluster", filepath = NULL)
```

Plot the estmiated curves

```{r fig.width=6, fig.height=4}
final_model = lapply(1:max(clust_res), log_mlik_each, Y, as.numeric(clust_res), X, NULL, formula, detailed = T)
level <- as.numeric(levels(as.factor(clust_res)))
ydf = setNames(as.data.frame(Y), 1:ns) |>
  mutate(time = 1:nt) |>
  tidyr::pivot_longer(1:ns, names_to = "region", names_transform = as.numeric) |>
  mutate(cluster = clust_res[region])
cluster2 = rep(level, table(clust_res))

preddf = purrr::map(level, function(x) final_model[[x]]$summary.fitted.values$mean) %>%
  purrr::map(~ matrix(., nrow = nt)) %>%
  do.call(cbind, .) |>
  as.data.frame() |>
  setNames(1:ns) |>
  mutate(time = 1:nt) |>
  tidyr::pivot_longer(1:ns, names_to = "newregion", names_transform = as.numeric) |>
  mutate(cluster = factor(cluster2[newregion]))
# Define the custom labeller function
custom_labeller <- function(cluster) {
  return(paste("Cluster", cluster))
}

# Apply the custom labeller to the facets
p <- ggplot(ydf) +
  geom_line(aes(x = time, y = value, group = region), color = "gray", linewidth = 0.2) +
  geom_line(data = preddf, aes(x = time, y = value, group = newregion),
            color = "red", linewidth = 0.3, linetype = 1) +
  facet_wrap(~ cluster, ncol = 5, scales = "free_y", labeller = labeller(cluster = as_labeller(custom_labeller))) +
  theme_bw() +
  theme(legend.position = "none", legend.text = element_text(size = 7)) +
  labs(color = "Cluster", y = "Y", x = "Time")
p
```
[Next: US COVID Data](US_Covid.html)
