---
title: "sfclust - Create stars dataset"
author: "Ruiman Zhong"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{3. sfclust - Create stars dataset}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
  }

  /* Main content that spans the full width */
  .main-content {
    margin: 0; /* Remove the margin for full-width content */
    padding: 20px; /* Optional padding for better readability */
    width: 100%; /* Take up 100% of the page width */
    box-sizing: border-box; /* Ensure padding doesn’t cause overflow */
  }

  h1, h2, h3 {
    margin-left: 0; /* Ensure headers are aligned properly */
  }

  .page-break {
    page-break-after: always;
  }
</style>

<div class="main-content">

## Create spatial domain

We start by defining a spatial domain for our simulation studies. To ensure reproducibility, we set a random seed using `set.seed(7)`. A bounding box is then defined with specific minimum and maximum x and y coordinates using the st_bbox function, representing a rectangular domain [0, 1] x [0, 1]. This bounding box is converted into a simple feature geometry using `st_as_sfc()`, creating a spatial feature object box that represents the domain boundary.
```{r warning=FALSE, include=FALSE}
library(sf)
library(ggplot2)
library(igraph)
library(ggraph)
library(stars)
set.seed(7)
bbox <- st_bbox(c(xmin = 0, ymin = 0, xmax = 1, ymax = 1))
box <- st_as_sfc(bbox) # Define a bounding box
```
Next, we generate 100 random sample points within the bounding box using `st_sample()`. These points serve as the basis for constructing a Voronoi tessellation. The `st_voronoi()` function generates Voronoi polygons. The resulting Voronoi polygons are organized into a simple feature collection using st_sf, creating the object geodata that holds the geometry of these polygons.
```{r}
n <- 100
points <- st_union(st_sample(box, size = n))
vor <- st_voronoi(points, box)
geodata <-st_sf(geometry = st_intersection(st_cast(vor), box))
ggplot(geodata)+geom_sf()
```

## Create clusters

The created tessellation partitions the domain into distinct, non-overlapping areas. These areas serve as the foundation for the subsequent steps of the analysis, where the domain will be transformed into a graph. Using this graph, we will compute a Minimum Spanning Tree (MST) and create clusters by removing a specified number of edges. In this case, the prepared spatial domain will eventually be used to generate 10 clusters. This initial step ensures that the spatial structure is well-defined and ready for further analysis.

```{r warning=FALSE}
set.seed(81)
adj_mat <- st_touches(geodata) %>% as("matrix")
adj_mat_weighted <- adj_mat * runif(length(adj_mat))
graph <- graph_from_adjacency_matrix(adj_mat_weighted, mode = "upper", weighted
= TRUE)
mstgraph <- mst(graph)
coords <- st_coordinates(st_centroid(geodata))
plot(mstgraph, layout = coords)
```

By removing n-1 edges with the highest weights from the MST, we can partition the tree into n separate clusters. In this example, we aim to create 10 clusters (`n = 10`). The code identifies the edges to remove by sorting the edge weights of the MST `(E(mstgraph)$weight)` in ascending order and selecting the first n-1 edges using their indices. These edges are then removed from the MST using the `delete_edges()` function, resulting in a disconnected graph.
```{r fig.height=4, warning=FALSE, , fig.width=6}
# remove the edges with higher weights
n = 10
edgeid_rm <- order(E(mstgraph)$weight)[1:(n-1)]
graph_comp <- components(delete_edges(mstgraph, edgeid_rm))
```
The `geodata` object is updated to include the original MST (mstgraph), the full graph (graph), and unique identifiers for each polygon (ID). Finally, we visualize the clustered MST using plot, where each vertex is colored based on its cluster membership. 
```{r}
geodata$membership <- graph_comp$membership
geodata$mst <- mstgraph
geodata$graph <- graph
plot(delete_edges(mstgraph, edgeid_rm), vertex.color = hcl.colors(n, palette = "Set 2")[geodata$membership], layout = coords)
```

Let's visualize the clusters we created.
```{r fig.height=4, fig.width=6, warning=FALSE}
ggplot() +
  geom_sf(data = geodata, aes(fill = factor(membership))) +  # Color by cluster and outline polygons
  scale_fill_viridis_d(option = "plasma") +  # Use a color scale for the clusters
  labs(title = "Voronoi Tessellation with MST-based Clusters", fill = "Cluster") +
  theme_minimal()
```

## Add temporal dynamics into spatial clusters

To incorporate temporal dynamics into our spatial clusters, we simulate cluster-specific trends over time using an additive model. The `fda::create.bspline.basis()` function is used to construct a B-spline basis over the time interval [0, 1], with 16 basis functions of order 3 (quadratic splines). This basis provides the flexibility to model smooth trends over time. The basis is evaluated at the time points using `fda::eval.basis()`.

To simulate temporal variability, we define autoregressive processes (simar) with predefined parameters. Each cluster's trend is generated by simulating coefficients (beta) for the basis functions using an AR(1) or AR(2) process. The `arima.sim()` function generates these coefficients, ensuring the temporal dependence in the trends.

The intercepts for the trends are adjusted to center the data around zero by computing the mean effects (beta0) from the product of the basis matrix (`X`) and the coefficients (beta). These intercept adjustments are repeated for each time point.

```{r fig.height=4, fig.width=6, warning=FALSE}
time = seq(0,1,length.out = 100)
set.seed(1)
bs <- fda::create.bspline.basis(c(0,1), 16, norder = 3)
X <- fda::eval.basis(time, bs)
thetas <- rep(list(c(0.95), c(0.5, 0.44)), each = 5)
simar <- function(n, tau2, theta)
arima.sim(n = n, list(ar = theta), sd = sqrt(tau2))
beta <- do.call(cbind, purrr::map(thetas, ~ as.numeric(simar(16, 0.1, .x))))
beta0 <- - colMeans(X %*% beta)
eta0 <- rep(beta0, each = 100) + X %*% beta
```
To simulate observed data that includes variability specific to each cluster, we add noise to the previously generated cluster trends. We start by defining a vector sigmas that contains the standard deviations for the noise associated with each cluster. These values are scaled by a factor of two to adjust the noise levels:
```{r}
usigmas <- c(0.01, 0.05, 0.02, 0.05, 0.02) * 2
```
For each spatial unit in geodata, we retrieve the corresponding cluster trend from `eta0` using the cluster membership. We then add random noise drawn from a normal distribution with mean zero and a standard deviation specific to that cluster. We visualize the simulated observations over time using the matplot function:
```{r fig.height=4, fig.width=6, warning=FALSE}
Y = purrr::map(
    1:nrow(geodata),
    ~ eta0[, geodata$membership[.]] + rnorm(100, mean = 0, sd = usigmas[geodata$membership[.]])
    )
Y = do.call(cbind, Y)
matplot(time, Y, type = "l", lty = 1, xlab = "time", ylab = "Obervations")
```

## Create spatial-temporal response
To represent the simulated spatiotemporal data in a structured format, we create an stars object from the matrix Y using the stars package. This object allows us to store spatial and temporal dimensions together, providing a foundation for further analysis or visualization. Here’s how this is accomplished:

First, the spatial coordinates for each spatial unit are extracted using `st_centroid(geodata)`. This calculates the centroids of the polygons in the `geodata` object. These points represent the spatial locations associated with each unit.
Next, we convert the observation matrix Y into a stars object using the `st_as_stars()` function. The Y matrix, where rows correspond to time points and columns to spatial units, is interpreted as a multidimensional array. We then define the dimensions of the stars object using st_dimensions. Specifically, we set the temporal dimension name as `time` associating it with the `time` sequence defined earlier, and the spatial dimension name as `geometry`, linking it to the centroid coordinates obtained from `coords$geometry`.
```{r warning=FALSE}
stdata <- st_as_stars(Y = Y)
st_dimensions(stdata) <- st_dimensions(time = time,geometry = geodata$geometry)
```

## Create stars dataframe including response and covariates

In this section, we show how to create a `stars` dataset that includes response `Y` and covariates 'X1' and `X2`. We will utilize previously created map, response `Y`, and cluster label.
```{r warning=FALSE}
# compute fixed effects
X = poly(time, 2, raw = TRUE, simple = TRUE)
X1 <- X[, 1]
X2 <- X[, 2]

# Expand X1 and X2 to match the space-time dimensions (100 time points, 100 space points)
# Replicate X1 and X2 across space
X1_expanded <- matrix(rep(X1, time = 100), nrow = 100, ncol = 100)
X2_expanded <- matrix(rep(X2, time = 100), nrow = 100, ncol = 100)
```
Finally, we combine the two covariates and our response.
```{r}
# Combine X1, X2, and Y into a single stars object
stdata <- st_as_stars(Y = Y, X1 = X1_expanded, X2 = X2_expanded)
st_dimensions(stdata) <- st_dimensions(time = time,geometry = geodata$geometry)
```
