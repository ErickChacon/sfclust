---
title: "Spatial_functional_clustering_for_glm_data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Spatial_functional_clustering_for_Poisson_glm_data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

All simulated datasets are included in the folder \textcolor{red}{Sim-Data}. Here, we take the shifted Doppler signals with b-splines basis functions as an example to illustrate the usage of the Fclust-RST method. 

- We first install and load the required R packages:
```{r echo=TRUE, message=FALSE, warning=FALSE}
rm(list = ls())
packages = c( "gridExtra", "deldir", "fields", "igraph",  "devtools", "ggplot2", "Matrix.utils", "grid", 
             "parallel", "class", "spgwr", 'sf',
             "salso", 'spfc',
             "fda","mclust")

## Now load or install&load all packages
package.check <- lapply(
  packages,
  FUN = function(x) {
    if (!require(x, character.only = TRUE)) {
      # install.packages(x, dependencies = TRUE, 
      #          INSTALL_opts = '--no-lock', 
      #          repos = "http://cran.us.r-project.org")
      library(x, character.only = TRUE)
    }else
      library(x, character.only = TRUE)
  }
)
path_proj <- '~/Documents/project3'
path_data <- file.path(path_proj, "data")
path_raw <- file.path(path_data, "raw")
path_sim <- file.path(path_data, "simulated")
path_res <- file.path(path_proj, "data", "result","normal.RData")
path_im <- file.path(path_data,  "image")
```

- Read the R code for implementing Fclust-RST:


```{r echo=TRUE, message=FALSE, warning=FALSE}
##Load data
data = readRDS(file.path(path_sim, 'spatial-data-glm.rds'))
map <-  readRDS(file.path(path_raw, "spatial-domain-clusters.rds"))
cluster_true = data$cluster
eta = data$eta
Y = data$Y
nt=dim(Y)[1]; ns=dim(Y)[2]  
## build design matrix
time = seq(0, 1, length.out = nt)
# compute fixed effects
X = poly(time, 2, raw = TRUE, simple = TRUE)
population <- matrix(map$population, nrow = nt, ncol = ns, byrow = T)
```

- Obtain initial estimates for the between-cluster parameters. 
   \begin{itemize}
     \item  The hyperparameter $\mathcal{G}$ is fixed to be the true graph $\mathcal{G}_0$ used for generating the cluster-wise constant Doppler signals.      \item  The initial values of wavelet coefficients, $\{\hat{\boldsymbol{\beta}}(\mathbf{s})\}$, are obtained by using the least-square estimates for each location $\mathbf{s}$. 
     \item  For each edge of $\mathcal{G}$ connecting $\mathbf{s}$ and $\mathbf{s}^{\prime}$, the Euclidean distance of $\hat{\boldsymbol{\beta}}(\mathbf{s})$ and $\hat{\boldsymbol{\beta}}(\mathbf{s}^{\prime})$ is used as its edge weight. Then, the initial minimum spanning tree (MST), $\mathcal{T}^{(0)}$, is obtained based on $\mathcal{G}$ and its assigned edge weights. 
     \item  By removing $(k_p^{(0)}-1)$ edges of $\mathcal{T}^{(0)}$, we obtain $k_p^{(0)}$ initial clusters. 
  \end{itemize}
```{r echo=TRUE, warning=FALSE}
# Build MST 
set.seed(43)
coords <- st_coordinates(st_centroid(map)[,3])
# create graph
adjacency_matrix <- sf::st_touches(map) %>% as("matrix")
graph0 <- graph.adjacency(adjacency_matrix, mode = "undirected", diag = FALSE)

##Initial beta estimates
ratio = matrix(0,nrow = nt, ncol = ns)
for(i in 1:ns){ratio[,i] = as.matrix(Y[,i]/population[,i])}

######  Construct an initial MST
beta.ini= ginv(t(X) %*% X) %*% t(X) %*% eta # p * s
beta.ini = t(beta.ini) 

inc.mat=get.edgelist(graph0, names = F)
weights=sqrt(sum(beta.ini[inc.mat[,1]]-beta.ini[inc.mat[,2]])^2)
E(graph0)$weights=weights
mstgraph.ini=mst(graph0)

V(mstgraph.ini)$vid=1:ns
rmid=order(E(mstgraph.ini)$weights, decreasing = TRUE)[1:15]

graph_comp=components(delete.edges(mstgraph.ini, rmid))
membership.ini=graph_comp$membership

membership=membership.ini ##cluster membership
mstgraph=mstgraph.ini     ## initial MST
cluster_true 
```
- Initialize model parameters:
 target is list containging response Y and covariate X
 hyperpar is a parameter contains the penalty of the number of clusters
 init_val includes parameters of initial beta, cluster memebership and spanning tree.
 inla.extra and formula are components of INLA function. inla.extra descrbes the model type (family, normal, poisson, binomial), and potential parameters; 
 formula is for fitting within-cluster model, thus, the response name should be 'Yk'
```{r echo=TRUE, message=FALSE, warning=FALSE}
clust_uniq=sort(unique(membership.ini)); k=length(clust_uniq)
target <- list(Y = eta, X = X)
hyperpar<-list("c"= 0.5)
###List of initial values
init_val<-list("beta"=beta.ini, 
               "cluster"= membership.ini, 
               "trees"=mstgraph.ini)
formula <- Yk~ 1  + Xk
MCMC= 10000; BURNIN=5000; THIN=1
```
- Run the Fclust-RST method on normal response data:
```{r message=TRUE, warning=FALSE, include=FALSE}
# library(RhpcBLASctl)
# blas_get_num_procs()
# blas_set_num_threads(6)
system.time({
     BayesClust(target,formula, inla.extra, graph0, init_val, hyperpar, MCMC, BURNIN, THIN, path_res, seed = 1234)
 })

# normal case , MCMC = 10000, THIN = 1:
# user   system  elapsed 
# 35545.59 23587.49 44591.56 
```

- Plot the clustering results:

```{r echo=TRUE, message=FALSE}

#####Load the results of Fclust-RST
load(file.path(path_res))
cluster_out_burn = cluster_out[1:10,]
brazil$cluster_true = cluster_true
pihat <- salso::psm(cluster_out_burn)
clust_idx=which.min(salso::binder(cluster_out_burn, pihat))
clust_res=cluster_out_burn[clust_idx,]
brazil$cluster_true = cluster_true
###Obtain the adjusted Rand index with the true partition
adjustedRandIndex(clust_res, cluster_true)
n.sample=(MCMC-BURNIN)/THIN ###Number of posterior samples
png(file.path(path_im,'Cluster Procedure AR.png'))
print(fields::image.plot(cluster_out, main="Cluster Procedure", axes=TRUE, xlab = 'Iterations', ylab = 'Memembership'))
dev.off()
```

- Plot the estimated curve (in red) versus the observed ones (in grey) for each cluster:

```{r echo=TRUE, message=FALSE}
p = max(clust_res)
col_n=gray.colors(80, alpha=0.5)

ymin=min(ratio); ymax=max(ratio)
png(width = 960, height = 480, file.path(path_im,'Clustered Function results AR.png'))
par(mfrow = c(1,4))
time = seq(0,1, length.out = nt)
for(k in 1:p){
IND=which(clust_res==k)
plot(time, eta[,IND[1]], "l", col=col_n[40], xlab="t", ylab="f(t)",
main=sprintf("Cluster %d", k), ylim=c(ymin, ymax))
m <- t(matrix(result[[k]]$summary.fitted.values$mean, nrow = nt))
for(i in 2:length(IND))
lines(time, eta[,IND[i]], col=col_n[40])
lines(time, colMeans(m), col="red")
}
dev.off()
```

### test
beta = cbind(
    c(1, 0), c(-1, 0), c(0, 0), c(-3, 3), c(3, -3),
    c(1, 0), c(-1, 0), c(0, 0), c(-3, 3), c(3, -3)
)

- Run Model on Poisson data

```{r}
data = readRDS(file.path(path_sim, 'spatial-data-glm.rds'))
map <-  readRDS(file.path(path_raw, "spatial-domain-clusters.rds"))
cluster_true = as.numeric(data$cluster)
Y = data$Y
nt=dim(Y)[1]; ns=dim(Y)[2]  
## build design matrix
time = seq(0, 1, length.out = nt)
# compute fixed effects
X = poly(time, 2, raw = TRUE, simple = TRUE)
population <- matrix(map$population, nrow = nt, ncol = ns, byrow = T)
```
```{r echo=TRUE, message=FALSE, warning=FALSE}
clust_uniq=sort(unique(membership.ini)); k=length(clust_uniq)
target <- list(Y = data$Y, X = X, N = population)
hyperpar<-list("c"= 0.5)
###List of initial values
init_val<-list("beta"=beta.ini, 
               "cluster"= membership.ini, 
               "trees"=mstgraph.ini)
formula = Yk ~ 1 + Xk + f(id, model = 'iid',hyper = list(prec = list(prior = "loggamma", param = c(0.1, 0.1))))
MCMC= 3000; BURNIN=500; THIN=1
```
```{r message=TRUE, warning=FALSE, include=FALSE}
path_res <- file.path(path_proj, "data", "result","poisson-glm-c10.RData")
system.time({
     BayesClust(target,formula,family = 'poisson', graph0, init_val, hyperpar,correction = F,detailed = F, MCMC, BURNIN, THIN, path_res, seed = 1234)
 })
# 1000 iterations
#     user   system  elapsed 
# 6490.794 3292.907 6192.041 
```
In case the chain does not converge, we can continue running the chain on the present results
```{r}
path_res <- file.path(path_proj, "data", "result","poisson-glm-c10_continue.RData")
membership.ini <- cluster_out[nrow(cluster_out),]
mstgraph.ini <- MST_out[[length(MST_out)]]
clust_uniq=sort(unique(membership.ini)); k=length(clust_uniq)
target <- list(Y = data$Y, X = X, N = population)
hyperpar<-list("c"= 0.5)
init_val<-list("beta"=beta.ini, 
               "cluster"= membership.ini, 
               "trees"=mstgraph.ini)
MCMC= 2000; BURNIN=500; THIN=1 
 BayesClust(target,formula,family = 'poisson', graph0, init_val, hyperpar,correction = F,detailed = F, MCMC, BURNIN, THIN, path_res, seed = 12345)
```
```{r}
load(file.path(path_res))
clust_res = cluster_out[length(MST_out),]
p = max(clust_res)
result=lapply( 1:p, FUN = evalLogMLike_each_INLA, Y, clust_res, X, population, family = "poisson",formula, correction = FALSE, detailed = T)
# result_t=lapply( 1:p, FUN = evalLogMLike_each_INLA, Y, cluster_true, X, population, family = "poisson",formula, correction = FALSE, detailed = F)
#   log_like=sum(unlist(result))
#   log_like_t = sum(unlist(result_t))
#   log_like
#   log_like_t
```
```{r echo=TRUE, message=FALSE}
p = max(clust_res)
col_n=gray.colors(80, alpha=0.5)

ymin=min(exp(eta)); ymax=max(exp(eta))
png(width = 960, height = 480, file.path(path_im,'Clustered Function results poly_glm_poisson.png'))
par(mfrow = c(2,4))
time = seq(0,1, length.out = nt)
for(k in 1:p){
IND=which(clust_res==k)
plot(time, exp(eta)[,IND[1]], "l", col=col_n[40], xlab="t", ylab="f(t)",
main=sprintf("Cluster %d", k), ylim=c(ymin, ymax))
m <- t(matrix(result[[k]]$summary.fitted.values$mean, nrow = nt, byrow = FALSE))
for(i in 2:length(IND))
lines(time, exp(eta[,IND[i]]), col=col_n[40])
lines(time, colMeans(m), col="red")
}
dev.off()

png(file.path(path_im,'Cluster Procedure poly_glm_poisson_last300.png'))
print(fields::image.plot(t(cluster_out[1550:1850,]), main="Cluster Procedure", axes=TRUE, xlab = 'Memembership', ylab = 'Iterations'))
dev.off()
```
