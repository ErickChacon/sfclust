
---
title: "Creating Custom Initial Graphs"
author: "Ruiman Zhong"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Custom Initial Graphs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction

The `sfclust` package currently supports the use of adjacency matrices for graph creation. However, users who need more advanced or customized graphs can still create them using external libraries and pass these graphs into the clustering functions.
This vignette demonstrates how to use other methods like k-nearest neighbors, relative neighborhood graphs, and Delaunay triangulation to create custom graphs.

# Available Graph Construction Methods

### 1. K-Nearest Neighbors (KNN)
Users can create a k-nearest neighbors (KNN) graph using the `nng()` function from the `cccd` package or write a custom function. Below is an example using the `cccd` package:

```{r warning=FALSE}
library(cccd)
library(sfclust)
library(sf)
library(ggraph)
data("us_covid")
map <-  us_covid$map
coords <- st_coordinates(st_centroid(map))  # Get coordinates from spatial object

# Create KNN graph
graph_knn <- nng(coords, k = 5)
edgelist <- ends(graph_knn, E(graph_knn))
weight <- sqrt(apply((coords[edgelist[, 1], ] - coords[edgelist[, 2], ])^2, 1, sum))
E(graph_knn)$weight <- weight
mst_knn <- mst(graph_knn)
par(mfrow = c(1,2))
plot(graph_knn, layout = coords, title = "Full graph" )
plot(mst_knn, layout = coords, title = "MST")
```

### 2. RNN with Geographical Distance
In cases where geographical distances are important, the following code shows how to use `rdist.earth()` from the `fields` package:

```{r}
library(fields)

eps <- 5
adj <- rdist(coords)
adj[adj > eps] <- 0
graph_rnn <- graph_from_adjacency_matrix(adj, mode = "upper", weighted = TRUE)
mst_rnn <- mst(graph_rnn)
par(mfrow = c(1,2))
plot(graph_rnn, layout = coords, title = "Full graph" )
plot(mst_rnn, layout = coords, title = "MST")
```

### 3. Custom Graph from Delaunay triangulation
Delaunay triangulation offers a way to connect spatial points, forming edges based on proximity. This method ensures that no point lies inside the circumcircle of any triangle, making it well-suited for spatial data.

Once the graph is constructed using Delaunay triangulation, a Minimum Spanning Tree (MST) can be derived. The MST minimizes the total edge length while connecting all points without forming cycles, making it useful for clustering spatial points.

In the `dentrigraph()` function, Delaunay triangulation is used to create a full graph, and the MST is extracted from this graph, simplifying the connections while retaining the core spatial relationships.

```{r}
library(deldir) 

dentrigraph <- function(coords) {
  # Perform Delaunay triangulation using the deldir package
  delaunay_triangulation <- deldir(coords[, 1], coords[, 2])
  
  # Extract the edges from the triangulation (delaunay network)
  triangulation_edges <- delaunay_triangulation$delsgs  # Segment data frame
  
  # Create the graph from the triangulation edges
  graph_full <- graph_from_edgelist(as.matrix(triangulation_edges[, c("ind1", "ind2")]), directed = FALSE)
  
  # Calculate the edge weights (Euclidean distance between points)
  coords1 <- coords[triangulation_edges$ind1, ]
  coords2 <- coords[triangulation_edges$ind2, ]
  weights <- sqrt(rowSums((coords1 - coords2)^2))
  E(graph_full)$weight <- weights  # Assign weights to the edges
  
  # Generate the Minimum Spanning Tree (MST) from the full graph
  graph_mst <- mst(graph_full, weights = E(graph_full)$weight)
  
  return(list(graph_full = graph_full, mst_graph = graph_mst))
}

graph_list <- dentrigraph(coords)

# Full graph
plot(graph_list$graph_full, layout = coords)

# MST graph
plot(graph_list$mst_graph, layout = coords)
```
# Create MST and initial clusters
We provide several methods for constructing both a Minimum Spanning Tree (MST) and a full graph from spatial data. In this example, we demonstrate how to create an MST and initialize clusters using the K-Nearest Neighbors (KNN) method.

First, we extract the adjacency matrix from the graph_knn object. Then, using this matrix, we initialize clusters by specifying the number of clusters (nclust).
```{r}
adj_matrix_knn <- as_adjacency_matrix(graph_knn, sparse = FALSE)

geodata <- initial_cluster(adj_matrix_knn, nclust = 5)
```
Users can also provide any custom adjacency matrix to generate geodata, giving them flexibility in how they structure their initial graph.

# Passing Custom Graphs to the `sfclust` Package

Once you have created the initial parameters based on your custom graph, you can pass it into the packageâ€™s functions like so:

```{r eval=FALSE}
formula <- Y ~ 1 + f(idt, model = "ar1")
# Assuming 'graph_custom' is the graph you've created:
result <- sfclust(Y = us_covid$Y, graphdata = geodata, formula = formula, niter = 1000)
```

This approach allows you to control how the initial graph is constructed, enabling flexibility for specific use cases or datasets.

# Conclusion

While the default graph creation method in the package is adjacency matrices, users can still leverage external tools and libraries to create custom graphs, giving them greater control over how their spatial data is structured. 
